<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Bosses – Created by Kai Nava</title>

  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      user-select: none;
      font-family: system-ui, sans-serif;
    }
    canvas {
      border: 4px solid white;
      border-radius: 8px;
      background: #87ceeb;
    }
  </style>
</head>
<body>
<canvas id="game" width="900" height="500"></canvas>

<script>
/* ======================================================================
   THE BOSSES – Created by Kai Nava
   Two-level platformer with characters, coins, enemies, and boss battle
   ====================================================================== */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let gameState = "title";
let characterChoice = "bart";
let facingDir = 1;
const maxLevelRetries = 3;
let retriesLeft = maxLevelRetries;

const keys = {};
document.addEventListener("keydown", e => {
  keys[e.code] = true;

  if (gameState === "dead" && e.code === "KeyR" && retriesLeft > 0) {
    retriesLeft--;
    restartLevel();
  }
});
document.addEventListener("keyup", e => keys[e.code] = false);

async function resumeAudioContext() {
  if (audioContext.state === "suspended") {
    await audioContext.resume();
  }
}

canvas.addEventListener("click", async () => {
  await resumeAudioContext();

  if (gameState === "win") {
    resetGame();
  }
  if (gameState === "dead") {
    if (retriesLeft > 0) {
      retriesLeft--;
      restartLevel();
    } else {
      resetGame();
    }
  }
  if (gameState === "title") {
    gameState = "characterSelect";
  }
});

/* ======================================================================
   AUDIO SETUP
   ====================================================================== */

const audioContext = new (window.AudioContext || window.webkitAudioContext)();
let musicPlaying = false;

function playTone(freq, duration, vol = 0.1, type = "triangle") {
  const now = audioContext.currentTime;
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  osc.type = type;
  osc.connect(gain);
  gain.connect(audioContext.destination);

  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(vol, now + 0.05);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

  osc.start(now);
  osc.stop(now + duration + 0.05);
}

function startMusic() {
  if (musicPlaying) return;
  musicPlaying = true;

  const melody = [262, 330, 392, 523, 392, 330, 349, 466];
  const bass = [110, 147, 165, 196];
  let noteIndex = 0;
  let bassIndex = 0;

  function playNextNote() {
    if (!musicPlaying || gameState === "title") return;
    playTone(melody[noteIndex % melody.length], 0.3, 0.08, "sine");
    playTone(bass[bassIndex % bass.length], 0.4, 0.05, "sawtooth");
    noteIndex++;
    if (noteIndex % 2 === 0) bassIndex++;
    setTimeout(playNextNote, 400);
  }
  
  playNextNote();
}

function playJumpSound() {
  playTone(440, 0.1, 0.08);
}

function playCoinSound() {
  playTone(760, 0.12, 0.12, "square");
  setTimeout(() => playTone(1200, 0.08, 0.08, "triangle"), 60);
}

function playHitSound() {
  playTone(150, 0.2, 0.12, "sawtooth");
}

/* ======================================================================
   PLAYER DEFINITIONS
   ====================================================================== */

const player = {
  x: 50,
  y: 350,
  vx: 0,
  vy: 0,
  r: 18,
  onGround: false,
  speed: 6,
  jumpVel: -14,
  maxJumps: 1,
  jumpsUsed: 0,
  coins: 0,
  health: 3,
  invincible: 0,
  shots: [],
  shotCooldown: 0,
  specialCooldown: 0,
  shieldTimer: 0,
  rainbowTrail: 0,
  coinMilestone: 0,
  helperBuff: 0,
  glide: false,
  momentum: 0,
  jumpHeld: false
};

const characterProfiles = {
  bart: {
    label: "Bart-Ball",
    color: "#f2c94c",
    detail: "#e67e22",
    specialName: "Skate Whiplash",
    description: "Chains speed into a whiplash spin shot that pierces foes.",
    special() {
      const burstSpeed = 14 + player.momentum * 2;
      player.vx += facingDir * burstSpeed;
      player.shots.push({ x: player.x, y: player.y - 5, vx: facingDir * 14, r: 9, ttl: 70, pierce: 2 });
      player.invincible = Math.max(player.invincible, 30);
      player.momentum = Math.min(player.momentum + 1, 3);
      playTone(820, 0.2, 0.12);
    }
  },
  lisa: {
    label: "Lisa-Ball",
    color: "#f9d371",
    detail: "#8e44ad",
    specialName: "Sound Shield",
    description: "Shield up and fire a resonant pulse that slows enemies.",
    special() {
      player.invincible = Math.max(player.invincible, 90);
      player.shieldTimer = 90;
      player.shots.push({ x: player.x, y: player.y - 5, vx: facingDir * 8, r: 10, ttl: 60, slow: true, pierce: 3 });
      playTone(520, 0.25, 0.14);
    }
  },
  unicorn: {
    label: "Unicorn-Ball",
    color: "#a29bfe",
    detail: "#ffeaa7",
    specialName: "Prism Ascend",
    description: "Double jump and glide while leaving a slowing prism trail.",
    special() {
      player.vy = -18;
      player.rainbowTrail = 50;
      player.jumpsUsed = Math.max(player.jumpsUsed - 1, 0);
      playTone(900, 0.2, 0.1);
    }
  }
};

const helperChief = {
  x: 120,
  y: 330,
  active: false,
  bubbleTimer: 0,
  bubbleText: "",
  cooldown: 0,
  shieldTarget: 0
};

/* ======================================================================
   LEVEL DATA
   ====================================================================== */

let currentLevel = 1;
const totalLevels = 4;

const bossConfigs = {
  3: {
    name: "Horned Titan",
    health: 10,
    maxHealth: 10,
    color: "#b23a48",
    accent: "#ffe066",
    startX: 2600,
    startY: 180,
    behavior: "charge"
  },
  4: {
    name: "Neon Drone Queen",
    health: 14,
    maxHealth: 14,
    color: "#1b98e0",
    accent: "#7cf17c",
    startX: 2800,
    startY: 140,
    behavior: "hover"
  }
};

function spawnBoss(level) {
  const cfg = bossConfigs[level];
  if (!cfg) return null;
  return {
    ...cfg,
    phase: 1,
    dir: -1,
    attackTimer: 0,
    projectiles: [],
    active: false,
    x: cfg.startX,
    y: cfg.startY
  };
}

let boss = spawnBoss(3);

const levels = {
  1: {
    width: 2700,
    platforms: [
      {x: 0, y: 430, w: 520, h: 50},
      {x: 520, y: 370, w: 240, h: 32},
      {x: 840, y: 320, w: 200, h: 28},
      {x: 1160, y: 260, w: 240, h: 28},
      {x: 1460, y: 330, w: 260, h: 34},
      {x: 1780, y: 420, w: 240, h: 50},
      {x: 2080, y: 360, w: 220, h: 30},
      {x: 2380, y: 300, w: 200, h: 30}
    ],
    movingPlatforms: [
      {x: 620, y: 320, w: 180, h: 22, path: [{x: 620, y: 320}, {x: 980, y: 260}], speed: 1.2, target: 1},
      {x: 1880, y: 360, w: 140, h: 22, path: [{x: 1880, y: 360}, {x: 1880, y: 250}], speed: 1, target: 1}
    ],
    jumpPads: [
      {x: 920, y: 428, w: 80, h: 14, power: -18},
      {x: 2100, y: 356, w: 60, h: 12, power: -16}
    ],
    hazards: [
      {x: 420, y: 430, w: 80, h: 50},
      {x: 1320, y: 430, w: 120, h: 50}
    ],
    coins: [
      {x: 200, y: 360, taken:false},
      {x: 620, y: 300, taken:false},
      {x: 880, y: 260, taken:false},
      {x: 1240, y: 200, taken:false},
      {x: 1600, y: 280, taken:false},
      {x: 1900, y: 320, taken:false},
      {x: 2440, y: 240, taken:false}
    ],
    enemies: [
      {x: 700, y: 340, w: 40, h: 40, dir: 1, min: 620, max: 900},
      {x: 1500, y: 300, w: 42, h: 42, dir: -1, min: 1460, max: 1700},
      {x: 2200, y: 330, w: 40, h: 40, dir: 1, min: 2080, max: 2300}
    ],
    finish: {x: 2550, y: 250, w: 120, h: 22}
  },

  2: {
    width: 3200,
    platforms: [
      {x: 0, y: 430, w: 500, h: 50},
      {x: 520, y: 320, w: 260, h: 30},
      {x: 840, y: 250, w: 220, h: 30},
      {x: 1150, y: 190, w: 200, h: 28},
      {x: 1420, y: 240, w: 260, h: 30},
      {x: 1750, y: 300, w: 260, h: 30},
      {x: 2050, y: 360, w: 220, h: 30},
      {x: 2360, y: 280, w: 200, h: 28},
      {x: 2600, y: 220, w: 220, h: 26},
      {x: 2880, y: 170, w: 240, h: 24}
    ],
    movingPlatforms: [
      {x: 620, y: 360, w: 140, h: 20, path: [{x: 620, y: 360}, {x: 620, y: 240}], speed: 1.1, target: 1},
      {x: 1820, y: 340, w: 160, h: 20, path: [{x: 1820, y: 340}, {x: 2100, y: 200}], speed: 1.4, target: 1}
    ],
    jumpPads: [
      {x: 1080, y: 428, w: 90, h: 14, power: -20},
      {x: 2280, y: 276, w: 80, h: 12, power: -14}
    ],
    hazards: [
      {x: 400, y: 430, w: 90, h: 50},
      {x: 1300, y: 430, w: 130, h: 50},
      {x: 2000, y: 430, w: 110, h: 50}
    ],
    coins: [
      {x: 200, y: 360, taken:false},
      {x: 560, y: 270, taken:false},
      {x: 940, y: 200, taken:false},
      {x: 1220, y: 140, taken:false},
      {x: 1520, y: 180, taken:false},
      {x: 1840, y: 260, taken:false},
      {x: 2140, y: 320, taken:false},
      {x: 2420, y: 220, taken:false},
      {x: 2700, y: 160, taken:false},
      {x: 2980, y: 120, taken:false}
    ],
    enemies: [
      {x: 560, y: 290, w: 40, h: 40, dir: 1, min: 520, max: 760},
      {x: 1260, y: 210, w: 42, h: 42, dir: -1, min: 1150, max: 1420},
      {x: 1900, y: 270, w: 40, h: 40, dir: 1, min: 1750, max: 2100},
      {x: 2520, y: 250, w: 40, h: 40, dir: -1, min: 2360, max: 2600}
    ],
    finish: {x: 3020, y: 140, w: 140, h: 22}
  },

  3: {
    width: 3400,
    platforms: [
      {x: 0, y: 430, w: 360, h: 50},
      {x: 420, y: 360, w: 280, h: 34},
      {x: 760, y: 290, w: 260, h: 30},
      {x: 1100, y: 240, w: 240, h: 28},
      {x: 1420, y: 200, w: 240, h: 26},
      {x: 1760, y: 250, w: 260, h: 30},
      {x: 2100, y: 320, w: 320, h: 40},
      {x: 2480, y: 380, w: 360, h: 44},
      {x: 2880, y: 320, w: 360, h: 36}
    ],
    movingPlatforms: [
      {x: 540, y: 300, w: 140, h: 22, path: [{x: 540, y: 300}, {x: 540, y: 180}], speed: 1.2, target: 1},
      {x: 1680, y: 220, w: 160, h: 24, path: [{x: 1680, y: 220}, {x: 1880, y: 160}], speed: 1.5, target: 1}
    ],
    jumpPads: [
      {x: 920, y: 428, w: 100, h: 14, power: -22},
      {x: 2280, y: 360, w: 80, h: 14, power: -18}
    ],
    hazards: [
      {x: 360, y: 430, w: 60, h: 50},
      {x: 1020, y: 430, w: 80, h: 50},
      {x: 1960, y: 430, w: 120, h: 50},
      {x: 2720, y: 430, w: 100, h: 50}
    ],
    coins: [
      {x: 180, y: 360, taken:false},
      {x: 520, y: 280, taken:false},
      {x: 820, y: 240, taken:false},
      {x: 1180, y: 190, taken:false},
      {x: 1520, y: 140, taken:false},
      {x: 1820, y: 200, taken:false},
      {x: 2140, y: 270, taken:false},
      {x: 2460, y: 340, taken:false},
      {x: 2760, y: 300, taken:false},
      {x: 3120, y: 280, taken:false}
    ],
    enemies: [
      {x: 620, y: 320, w: 44, h: 44, dir: 1, min: 540, max: 740},
      {x: 1320, y: 220, w: 44, h: 44, dir: -1, min: 1100, max: 1420},
      {x: 2040, y: 300, w: 46, h: 46, dir: 1, min: 1760, max: 2140}
    ],
    finish: null,
    isBossLevel: true
  },

  4: {
    width: 3600,
    platforms: [
      {x: 0, y: 430, w: 360, h: 50},
      {x: 420, y: 360, w: 260, h: 32},
      {x: 740, y: 290, w: 260, h: 30},
      {x: 1060, y: 230, w: 260, h: 28},
      {x: 1380, y: 180, w: 260, h: 24},
      {x: 1720, y: 240, w: 240, h: 26},
      {x: 2040, y: 300, w: 260, h: 30},
      {x: 2360, y: 360, w: 260, h: 30},
      {x: 2680, y: 300, w: 260, h: 30},
      {x: 3000, y: 240, w: 260, h: 28},
      {x: 3280, y: 200, w: 260, h: 28}
    ],
    movingPlatforms: [
      {x: 560, y: 320, w: 160, h: 22, path: [{x: 560, y: 320}, {x: 560, y: 200}], speed: 1.3, target: 1},
      {x: 1860, y: 270, w: 160, h: 22, path: [{x: 1860, y: 270}, {x: 2140, y: 190}], speed: 1.5, target: 1},
      {x: 2800, y: 260, w: 160, h: 22, path: [{x: 2800, y: 260}, {x: 3080, y: 180}], speed: 1.6, target: 1}
    ],
    jumpPads: [
      {x: 960, y: 428, w: 90, h: 14, power: -20},
      {x: 2200, y: 356, w: 90, h: 14, power: -18},
      {x: 3200, y: 236, w: 80, h: 12, power: -16}
    ],
    hazards: [
      {x: 360, y: 430, w: 80, h: 50},
      {x: 1180, y: 430, w: 120, h: 50},
      {x: 2100, y: 430, w: 130, h: 50},
      {x: 3020, y: 430, w: 120, h: 50}
    ],
    coins: [
      {x: 180, y: 360, taken:false},
      {x: 520, y: 280, taken:false},
      {x: 860, y: 220, taken:false},
      {x: 1200, y: 160, taken:false},
      {x: 1520, y: 140, taken:false},
      {x: 1860, y: 200, taken:false},
      {x: 2180, y: 260, taken:false},
      {x: 2500, y: 320, taken:false},
      {x: 2820, y: 260, taken:false},
      {x: 3140, y: 210, taken:false},
      {x: 3420, y: 180, taken:false}
    ],
    enemies: [
      {x: 600, y: 320, w: 44, h: 44, dir: 1, min: 560, max: 760},
      {x: 1280, y: 200, w: 44, h: 44, dir: -1, min: 1060, max: 1380},
      {x: 1900, y: 280, w: 46, h: 46, dir: 1, min: 1720, max: 2140},
      {x: 2620, y: 300, w: 46, h: 46, dir: -1, min: 2360, max: 2680}
    ],
    finish: null,
    isBossLevel: true
  }
};

/* ======================================================================
   RESET GAME
   ====================================================================== */
function resetGame() {
  player.x = 50;
  player.y = 350;
  player.vx = 0;
  player.vy = 0;
  player.jumpsUsed = 0;
  player.coins = 0;
  player.health = 3;
  player.invincible = 0;
  player.shots = [];
  player.shotCooldown = 0;
  player.specialCooldown = 0;
  player.shieldTimer = 0;
  player.rainbowTrail = 0;
  player.coinMilestone = 0;
  player.helperBuff = 0;
  player.glide = false;
  player.momentum = 0;
  player.jumpHeld = false;

  currentLevel = 1;
  retriesLeft = maxLevelRetries;

  boss = spawnBoss(3);

  for (let lvl of Object.keys(levels)) {
    const numLvl = Number(lvl);
    if (!levels[numLvl]) continue;
    for (let c of levels[numLvl].coins) c.taken = false;
    for (let e of levels[numLvl].enemies) {
      e.dir = 1;
      e.x = e.min;
      e.defeated = false;
      e.slowTimer = 0;
    }
    if (levels[numLvl].movingPlatforms) {
      for (let m of levels[numLvl].movingPlatforms) {
        m.x = m.path[0].x;
        m.y = m.path[0].y;
        m.target = 1;
        m.vx = 0;
        m.vy = 0;
      }
    }
  }

  helperChief.active = false;
  helperChief.bubbleTimer = 0;
  helperChief.bubbleText = "";
  helperChief.cooldown = 0;
  helperChief.shieldTarget = 0;

  musicPlaying = false;
  gameState = "title";
}

function restartLevel() {
  player.x = 50;
  player.y = 350;
  player.vx = 0;
  player.vy = 0;
  player.jumpsUsed = 0;
  player.health = 3;
  player.invincible = 0;
  player.shots = [];
  player.shotCooldown = 0;
  player.specialCooldown = 0;
  player.shieldTimer = 0;
  player.rainbowTrail = 0;
  player.helperBuff = 0;
  player.glide = false;
  player.momentum = 0;
  player.jumpHeld = false;

  // reset collectibles and enemy positions for current level
  const lvl = levels[currentLevel];
  for (let c of lvl.coins) c.taken = false;
  for (let e of lvl.enemies) { e.dir = 1; e.x = e.min; e.defeated = false; e.slowTimer = 0; }
  if (lvl.movingPlatforms) {
    for (let m of lvl.movingPlatforms) {
      m.x = m.path[0].x;
      m.y = m.path[0].y;
      m.target = 1;
      m.vx = 0;
      m.vy = 0;
    }
  }

  // reset boss state when retrying boss levels
  if (levels[currentLevel].isBossLevel) {
    boss = spawnBoss(currentLevel);
    if (boss) boss.active = true;
  }

  gameState = "play";
  musicPlaying = false;
  startMusic();
}

/* ======================================================================
   PHYSICS
   ====================================================================== */

function applyCharacterTraits() {
  player.maxJumps = characterChoice === "unicorn" ? 2 : 1;
  if (characterChoice === "bart") {
    player.speed = 6 + player.momentum * 0.6;
  } else if (characterChoice === "lisa") {
    player.speed = 6;
  } else {
    player.speed = 6.2;
  }
}

function updateMovingPlatforms() {
  const moves = levels[currentLevel].movingPlatforms || [];
  for (let m of moves) {
    if (!m.path || m.path.length < 2) continue;
    const target = m.path[m.target];
    const dx = target.x - m.x;
    const dy = target.y - m.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 1) {
      m.target = (m.target + 1) % m.path.length;
      continue;
    }
    const stepX = (dx / dist) * m.speed;
    const stepY = (dy / dist) * m.speed;
    m.x += stepX;
    m.y += stepY;
    m.vx = stepX;
    m.vy = stepY;
  }
}

function handleJumpPads() {
  const pads = levels[currentLevel].jumpPads || [];
  for (let pad of pads) {
    const onPad =
      player.x + player.r > pad.x &&
      player.x - player.r < pad.x + pad.w &&
      player.y + player.r > pad.y &&
      player.y + player.r < pad.y + pad.h + 12;
    if (onPad && player.vy >= 0) {
      player.vy = pad.power;
      player.onGround = false;
      player.jumpsUsed = 1;
      playTone(620, 0.12, 0.12);
      if (characterChoice === "bart") player.momentum = Math.min(player.momentum + 1, 3);
    }
  }
}

function handleHazards() {
  const spikes = levels[currentLevel].hazards || [];
  for (let hz of spikes) {
    if (player.invincible > 0 || player.helperBuff > 0) continue;
    const touching =
      player.x + player.r > hz.x &&
      player.x - player.r < hz.x + hz.w &&
      player.y + player.r > hz.y;
    if (touching) {
      player.health--;
      player.invincible = 60;
      player.vy = -10;
      playHitSound();
      if (player.health <= 0) {
        gameState = "dead";
        musicPlaying = false;
      }
    }
  }
}

function applyPhysics() {
  applyCharacterTraits();
  player.vy += 0.7;

  if (keys["ArrowLeft"] || keys["KeyA"]) { player.vx = -player.speed; facingDir = -1; }
  else if (keys["ArrowRight"] || keys["KeyD"]) { player.vx = player.speed; facingDir = 1; }
  else player.vx = 0;

  if (characterChoice === "bart") {
    if (player.onGround && Math.abs(player.vx) > 0) {
      player.momentum = Math.min(player.momentum + 0.02, 3);
    } else {
      player.momentum = Math.max(player.momentum - 0.03, 0);
    }
  }

  if (characterChoice === "unicorn" && player.vy > 0 && (keys["Space"] || keys["ArrowUp"])) {
    player.vy *= 0.92;
    player.glide = true;
  } else {
    player.glide = false;
  }

  if (player.shotCooldown > 0) player.shotCooldown--;
  if (keys["KeyF"] && player.shotCooldown === 0) {
    const baseSpeed = characterChoice === "bart" ? 11 : characterChoice === "lisa" ? 9 : 10;
    const bullet = { x: player.x, y: player.y - 5, vx: facingDir * baseSpeed, r: 8, ttl: 90 };
    if (characterChoice === "lisa") bullet.slow = true;
    if (characterChoice === "bart") bullet.pierce = 1;
    player.shots.push(bullet);
    player.shotCooldown = characterChoice === "lisa" ? 14 : 18;
    playTone(520, 0.1, 0.09);
  }

  if (player.specialCooldown > 0) player.specialCooldown--;
  if (keys["KeyQ"] && player.specialCooldown === 0) {
    const profile = characterProfiles[characterChoice];
    if (profile && profile.special) {
      profile.special();
      player.specialCooldown = 120;
    }
  }

  const jumpKey = keys["Space"] || keys["ArrowUp"];
  if (jumpKey && !player.jumpHeld && player.jumpsUsed < player.maxJumps) {
    player.vy = player.jumpVel;
    player.jumpsUsed++;
    playJumpSound();
  }
  player.jumpHeld = jumpKey;

  if (player.rainbowTrail > 0) {
    player.rainbowTrail--;
    player.vy *= 0.9;
  }

  player.x += player.vx;
  player.y += player.vy;

  // Check if player fell off the map
  if (player.y > 600) {
    player.health = 0;
    gameState = "dead";
    musicPlaying = false;
  }

  if (player.invincible > 0) player.invincible--;
  if (player.shieldTimer > 0) player.shieldTimer--;
  if (player.helperBuff > 0) player.helperBuff--;

  updateMovingPlatforms();
  handlePlatforms();
  handleJumpPads();
  handleHazards();
  handleCoins();
  handleEnemies();
  handleShots();
  handleFinish();

  updateHelper();

  if (currentLevel === 3 && boss.active) {
    updateBoss();
  } else if (currentLevel === 4 && boss && boss.active) {
    updateBoss();
  }
}

function updateHelper() {
  helperChief.active = currentLevel > 1;
  if (!helperChief.active) return;

  const targetX = player.x - 80;
  const targetY = player.y - 20;
  helperChief.x += (targetX - helperChief.x) * 0.08;
  helperChief.y += (targetY - helperChief.y) * 0.08;

  if (helperChief.cooldown > 0) helperChief.cooldown--;
  if (helperChief.bubbleTimer > 0) helperChief.bubbleTimer--;

  if (helperChief.cooldown === 0 && player.health <= 1) {
    player.helperBuff = 180;
    helperChief.bubbleText = "Kevlar donuts online!";
    helperChief.bubbleTimer = 120;
    helperChief.cooldown = 360;
  }

  if (helperChief.bubbleTimer === 0 && Math.random() < 0.005) {
    const lines = ["Stay frosty!", "I got your six!", "Chief Wiggum reporting!", "Donut power!", "Protect and snack!"];
    helperChief.bubbleText = lines[Math.floor(Math.random() * lines.length)];
    helperChief.bubbleTimer = 90;
  }
}

/* ======================================================================
   PLATFORM COLLISIONS
   ====================================================================== */
function handlePlatforms() {
  const platList = [...levels[currentLevel].platforms, ...(levels[currentLevel].movingPlatforms || [])];
  player.onGround = false;

  for (let p of platList) {
    if (player.x + player.r > p.x &&
        player.x - player.r < p.x + p.w &&
        player.y + player.r > p.y &&
        player.y - player.r < p.y + p.h) {

      if (player.vy > 0 && player.y < p.y) {
        player.y = p.y - player.r;
        player.vy = 0;
        player.onGround = true;
        player.jumpsUsed = 0;
        if (p.vx) player.x += p.vx * 0.6;
      }
    }
  }
}

/* ======================================================================
   COINS
   ====================================================================== */
function handleCoins() {
  for (let c of levels[currentLevel].coins) {
    if (c.taken) continue;
    let dx = player.x - c.x;
    let dy = player.y - c.y;
    if (dx*dx + dy*dy < 30*30) {
      c.taken = true;
      player.coins++;
      playCoinSound();

      if (player.coins % 5 === 0 && player.coins > player.coinMilestone) {
        player.coinMilestone = player.coins;
        player.health = Math.min(5, player.health + 1);
        player.helperBuff = 120;
        helperChief.bubbleText = "Bonus donut shield!";
        helperChief.bubbleTimer = 90;
      }
    }
  }
}

/* ======================================================================
   ENEMY COLLISION
   ====================================================================== */
function handleEnemies() {
  for (let e of levels[currentLevel].enemies) {
    if (e.defeated) continue;

    const slowFactor = e.slowTimer && e.slowTimer > 0 ? 0.5 : 1;
    if (e.slowTimer && e.slowTimer > 0) e.slowTimer--;
    e.x += e.dir * 2 * slowFactor;
    if (e.x < e.min || e.x > e.max) e.dir *= -1;

    if (player.invincible > 0 || player.helperBuff > 0) continue;

    if (player.x + player.r > e.x &&
        player.x - player.r < e.x + e.w &&
        player.y + player.r > e.y &&
        player.y - player.r < e.y + e.h) {

      player.health--;
      player.invincible = 60;
      playHitSound();

      if (player.health <= 0) {
        gameState = "dead";
        musicPlaying = false;
      }
    }
  }
}

/* ======================================================================
   PLAYER PROJECTILES
   ====================================================================== */
function handleShots() {
  for (let i = player.shots.length - 1; i >= 0; i--) {
    const s = player.shots[i];
    s.x += s.vx;
    s.ttl--;

    if (s.ttl <= 0 || s.x < -50 || s.x > levels[currentLevel].width + 50) {
      player.shots.splice(i, 1);
      continue;
    }

    // Hit enemies
    for (let e of levels[currentLevel].enemies) {
      if (e.defeated) continue;
      if (s.x + s.r > e.x && s.x - s.r < e.x + e.w &&
          s.y > e.y - 30 && s.y < e.y + e.h + 30) { // vertical leniency
        e.defeated = true;
        if (s.slow) e.slowTimer = 240;
        if (!s.pierce || --s.pierce <= 0) {
          player.shots.splice(i, 1);
        }
        playHitSound();
        break;
      }
    }

    // Hit boss
    if (levels[currentLevel].isBossLevel && boss && boss.active) {
      const dx = s.x - boss.x;
      const dy = s.y - boss.y;
      if (Math.abs(dx) < 60 && Math.abs(dy) < 70) {
        boss.health--;
        if (!s.pierce || --s.pierce <= 0) {
          player.shots.splice(i, 1);
        }
        playTone(720, 0.12, 0.12);

        if (boss.health <= 0) {
          if (currentLevel < totalLevels) {
            currentLevel++;
            boss = spawnBoss(currentLevel);
            if (boss && levels[currentLevel].isBossLevel) boss.active = true;
            player.x = 50;
            player.y = 350;
          } else {
            gameState = "win";
            musicPlaying = false;
          }
        }
      }
    }
  }
}

/* ======================================================================
   FINISH FLAG
   ====================================================================== */
function handleFinish() {
  const f = levels[currentLevel].finish;
  if (!f) return;

  if (player.x > f.x && player.x < f.x + f.w &&
      player.y > f.y && player.y < f.y + f.h) {

    currentLevel++;
    player.x = 50;
    player.y = 350;

    if (levels[currentLevel] && levels[currentLevel].isBossLevel) {
      boss = spawnBoss(currentLevel);
      if (boss) boss.active = true;
    }
  }
}

/* ======================================================================
   BOSS BATTLE
   ====================================================================== */

function updateBoss() {
  if (!boss) return;
  boss.attackTimer++;
  const baseSpeed = boss.behavior === "hover" ? 1.8 : 1.5;
  boss.x += boss.dir * baseSpeed;
  const roamMin = 2000;
  const roamMax = 2800;
  if (boss.x < roamMin || boss.x > roamMax) boss.dir *= -1;

  if (boss.health < boss.maxHealth * 0.5 && boss.phase === 1) {
    boss.phase = 2;
  }

  const attackSpeed = boss.behavior === "hover" ? 60 : (boss.phase === 1 ? 80 : 50);

  if (boss.attackTimer > attackSpeed) {
    boss.attackTimer = 0;

    if (boss.behavior === "hover") {
      // Drone rain
      for (let i = -1; i <= 1; i++) {
        boss.projectiles.push({
          x: boss.x + i * 40,
          y: boss.y + 20,
          vx: i * 1.2,
          vy: 4,
          r: 9
        });
      }
    } else {
      const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
      boss.projectiles.push({
        x: boss.x,
        y: boss.y + 30,
        vx: Math.cos(angle) * (boss.phase === 1 ? 4 : 5.5),
        vy: Math.sin(angle) * (boss.phase === 1 ? 4 : 5.5),
        r: 10
      });
    }
  }

  // Update projectiles
  for (let i = boss.projectiles.length - 1; i >= 0; i--) {
    const p = boss.projectiles[i];
    p.x += p.vx;
    p.y += p.vy;

    if (p.x < -50 || p.x > 3300 || p.y < -80 || p.y > 600) {
      boss.projectiles.splice(i, 1);
      continue;
    }

    if (player.invincible > 0 || player.helperBuff > 0) continue;

    const dx = player.x - p.x;
    const dy = player.y - p.y;
    if (dx*dx + dy*dy < (player.r + p.r) * (player.r + p.r)) {
      player.health--;
      player.invincible = 60;
      playHitSound();
      boss.projectiles.splice(i, 1);

      if (player.health <= 0) {
        gameState = "dead";
        musicPlaying = false;
      }
    }
  }

  if (player.vy > 0 &&
      player.x > boss.x - 40 && player.x < boss.x + 80 &&
      player.y + player.r > boss.y - 20 && player.y < boss.y + 20) {

    boss.health--;
    player.vy = -10;
    playTone(800, 0.15, 0.1);

    if (boss.health <= 0) {
      if (currentLevel < totalLevels) {
        currentLevel++;
        boss = spawnBoss(currentLevel);
        if (boss && levels[currentLevel].isBossLevel) boss.active = true;
        player.x = 50;
        player.y = 350;
      } else {
        gameState = "win";
        musicPlaying = false;
      }
    }
  }

  const touchingBoss =
    player.x + player.r > boss.x - 40 &&
    player.x - player.r < boss.x + 40 &&
    player.y + player.r > boss.y &&
    player.y - player.r < boss.y + 80;

  if (touchingBoss && player.invincible === 0 && player.helperBuff === 0) {
    player.health--;
    player.invincible = 60;
    player.vx = boss.dir * 5;
    playHitSound();

    if (player.health <= 0) {
      gameState = "dead";
      musicPlaying = false;
    }
  }
}

/* ======================================================================
   DRAW FUNCTIONS
   ====================================================================== */

function drawCharacterBall(x, y, r, type) {
  const profile = characterProfiles[type] || characterProfiles.bart;
  const grad = ctx.createRadialGradient(x - 8, y - 8, r * 0.25, x, y, r);
  grad.addColorStop(0, "#fff");
  grad.addColorStop(1, profile.color);

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.stroke();

  ctx.fillStyle = profile.detail;
  ctx.beginPath();
  ctx.arc(x, y - r * 0.4, r * 0.4, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#0b090a";
  ctx.beginPath();
  ctx.arc(x - 6, y - 2, 3.5, 0, Math.PI * 2);
  ctx.arc(x + 6, y - 2, 3.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = profile.detail;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y + 6, 8, 0.15 * Math.PI, 0.85 * Math.PI);
  ctx.stroke();

  if (type === "bart") {
    ctx.fillStyle = "#2d3436";
    ctx.fillRect(x - r * 0.9, y - r - 6, r * 1.8, 8);
  }
  if (type === "lisa") {
    ctx.fillStyle = "#f94144";
    ctx.beginPath();
    ctx.moveTo(x - r * 0.6, y - r);
    ctx.lineTo(x, y - r - 10);
    ctx.lineTo(x + r * 0.6, y - r);
    ctx.fill();
  }
  if (type === "unicorn") {
    ctx.fillStyle = "#f72585";
    ctx.beginPath();
    ctx.moveTo(x, y - r - 6);
    ctx.lineTo(x + 6, y - r + 8);
    ctx.lineTo(x - 6, y - r + 8);
    ctx.fill();
  }
}

function drawCoin(c) {
  if (c.taken) return;
  const g = ctx.createRadialGradient(c.x - 4, c.y - 6, 4, c.x, c.y, 14);
  g.addColorStop(0, "#fff7b2");
  g.addColorStop(1, "#d9a000");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#7a5600";
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawEnemy(e) {
  const gradient = ctx.createLinearGradient(e.x, e.y, e.x, e.y + e.h);
  gradient.addColorStop(0, "#ff6b6b");
  gradient.addColorStop(1, "#c81d25");
  ctx.fillStyle = gradient;
  ctx.fillRect(e.x, e.y, e.w, e.h);
  ctx.fillStyle = "#1c1c1c";
  ctx.fillRect(e.x + 6, e.y + 10, 8, 8);
  ctx.fillRect(e.x + e.w - 14, e.y + 10, 8, 8);
  ctx.fillStyle = "#ffd166";
  ctx.fillRect(e.x + e.w / 2 - 6, e.y + e.h - 10, 12, 6);
}

function drawHelper(camX) {
  if (!helperChief.active) return;

  const x = helperChief.x - camX;
  const y = helperChief.y;
  ctx.fillStyle = "#2d3142";
  ctx.beginPath();
  ctx.roundRect(x - 22, y - 26, 44, 48, 8);
  ctx.fill();
  ctx.fillStyle = "#fcbf49";
  ctx.fillRect(x - 16, y - 20, 32, 10);
  ctx.fillStyle = "#fff";
  ctx.fillRect(x - 14, y - 10, 28, 16);
  ctx.fillStyle = "#000";
  ctx.fillRect(x - 8, y - 6, 8, 6);
  ctx.fillRect(x + 4, y - 6, 8, 6);
  ctx.fillStyle = "#f77f00";
  ctx.beginPath();
  ctx.arc(x, y + 4, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#9d0208";
  ctx.fillRect(x - 18, y + 8, 36, 6);

  if (helperChief.bubbleTimer > 0 && helperChief.bubbleText) {
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.strokeStyle = "#1d1d1d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(x - 70, y - 60, 140, 36, 10);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#1d1d1d";
    ctx.font = "12px sans-serif";
    ctx.fillText(helperChief.bubbleText, x - 60, y - 38);
  }
}

function drawBoss(camX) {
  const bodyGrad = ctx.createLinearGradient(0, boss.y, 0, boss.y + 100);
  bodyGrad.addColorStop(0, boss.color);
  bodyGrad.addColorStop(1, boss.phase === 2 ? boss.accent : "#0f172a");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.roundRect(boss.x - camX - 55, boss.y - 10, 110, 110, 16);
  ctx.fill();
  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.stroke();

  ctx.fillStyle = "#0b090a";
  ctx.beginPath();
  ctx.ellipse(boss.x - camX - 18, boss.y + 40, 16, 12, 0, 0, Math.PI * 2);
  ctx.ellipse(boss.x - camX + 22, boss.y + 40, 16, 12, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#fff3b0";
  ctx.fillRect(boss.x - camX - 28, boss.y + 12, 18, 18);
  ctx.fillRect(boss.x - camX + 10, boss.y + 12, 18, 18);
  ctx.fillStyle = "#0f172a";
  ctx.fillRect(boss.x - camX - 22, boss.y + 18, 8, 8);
  ctx.fillRect(boss.x - camX + 16, boss.y + 18, 8, 8);

  if (boss.behavior === "hover") {
    ctx.strokeStyle = boss.accent;
    ctx.beginPath();
    ctx.moveTo(boss.x - camX - 50, boss.y + 70);
    ctx.lineTo(boss.x - camX - 70, boss.y + 90);
    ctx.moveTo(boss.x - camX + 50, boss.y + 70);
    ctx.lineTo(boss.x - camX + 70, boss.y + 90);
    ctx.stroke();
  } else {
    ctx.fillStyle = boss.accent;
    ctx.beginPath();
    ctx.moveTo(boss.x - camX - 40, boss.y - 12);
    ctx.lineTo(boss.x - camX - 10, boss.y - 32);
    ctx.lineTo(boss.x - camX - 5, boss.y - 6);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(boss.x - camX + 40, boss.y - 12);
    ctx.lineTo(boss.x - camX + 10, boss.y - 32);
    ctx.lineTo(boss.x - camX + 5, boss.y - 6);
    ctx.fill();
  }

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(boss.x - camX - 70, boss.y - 40, 140, 16);
  ctx.fillStyle = boss.health > boss.maxHealth * 0.3 ? "#7cf17c" : "#ff4d6d";
  ctx.fillRect(boss.x - camX - 70, boss.y - 40, (boss.health / boss.maxHealth) * 140, 16);
  ctx.strokeStyle = "#111";
  ctx.strokeRect(boss.x - camX - 70, boss.y - 40, 140, 16);
  ctx.fillStyle = "#fff";
  ctx.font = "bold 14px sans-serif";
  ctx.fillText(boss.name, boss.x - camX - 50, boss.y - 25);

  for (let p of boss.projectiles) {
    const fireGrad = ctx.createRadialGradient(p.x - camX, p.y, 2, p.x - camX, p.y, p.r);
    fireGrad.addColorStop(0, boss.accent);
    fireGrad.addColorStop(1, boss.behavior === "hover" ? "#0ea5e9" : "#ff4800");
    ctx.fillStyle = fireGrad;
    ctx.beginPath();
    ctx.arc(p.x - camX, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawHUD() {
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(10, 10, 250, 50);

  ctx.fillStyle = "white";
  ctx.font = "18px sans-serif";
  ctx.fillText("Coins: " + player.coins, 20, 35);

  // Health hearts
  ctx.fillStyle = "red";
  for (let i = 0; i < player.health; i++) {
    ctx.fillText("❤", 150 + i * 25, 35);
  }

  // Level indicator
  ctx.fillText("Level: " + currentLevel, 20, 55);

  // Retries
  ctx.fillText("Retries: " + retriesLeft, 150, 55);

  ctx.fillStyle = "#ffd166";
  ctx.fillText("Special (Q): " + characterProfiles[characterChoice].specialName, 20, 75);
  ctx.fillStyle = player.specialCooldown === 0 ? "#7cf17c" : "#f07167";
  ctx.fillRect(180, 66, Math.max(0, 120 - player.specialCooldown), 6);
  ctx.strokeStyle = "#333";
  ctx.strokeRect(180, 66, 120, 6);

  if (player.helperBuff > 0) {
    ctx.fillStyle = "#7cf17c";
    ctx.fillText("Chief shield active", 20, 95);
  }

  if (currentLevel === 3 && boss.active) {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(canvas.width - 220, 10, 210, 60);
    ctx.fillStyle = "#FFD700";
    ctx.font = "16px sans-serif";
    ctx.fillText("Boss health: " + boss.health + "/" + boss.maxHealth, canvas.width - 210, 35);
    ctx.fillStyle = "#7cf17c";
    ctx.fillRect(canvas.width - 210, 42, (boss.health / boss.maxHealth) * 190, 8);
    ctx.strokeStyle = "#333";
    ctx.strokeRect(canvas.width - 210, 42, 190, 8);
    ctx.fillStyle = "white";
    ctx.fillText("Press F to fire or jump on head", canvas.width - 210, 60);
  } else if (currentLevel === 4 && boss && boss.active) {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(canvas.width - 220, 10, 210, 60);
    ctx.fillStyle = "#FFD700";
    ctx.font = "16px sans-serif";
    ctx.fillText(boss.name + ": " + boss.health + "/" + boss.maxHealth, canvas.width - 210, 35);
    ctx.fillStyle = "#7cf17c";
    ctx.fillRect(canvas.width - 210, 42, (boss.health / boss.maxHealth) * 190, 8);
    ctx.strokeStyle = "#333";
    ctx.strokeRect(canvas.width - 210, 42, 190, 8);
    ctx.fillStyle = "white";
    ctx.fillText("Q=Special • F=Fire", canvas.width - 210, 60);
  }
}

function drawBackdrop(camX) {
  const horizon = 170;

  // sky gradient
  const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
  sky.addColorStop(0, "#7fc8f8");
  sky.addColorStop(1, "#c7e9fb");
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // distant mountains with subtle parallax
  const mountainOffset = camX * 0.15;
  ctx.fillStyle = "#7ba2d4";
  ctx.beginPath();
  ctx.moveTo(-200 - mountainOffset, horizon + 30);
  ctx.lineTo(150 - mountainOffset, 80);
  ctx.lineTo(420 - mountainOffset, horizon + 30);
  ctx.lineTo(canvas.width + 200 - mountainOffset, horizon + 30);
  ctx.lineTo(canvas.width + 200 - mountainOffset, canvas.height);
  ctx.lineTo(-200 - mountainOffset, canvas.height);
  ctx.fill();

  ctx.fillStyle = "#5f7bb5";
  ctx.beginPath();
  ctx.moveTo(50 - mountainOffset * 0.7, horizon + 60);
  ctx.lineTo(320 - mountainOffset * 0.7, 120);
  ctx.lineTo(620 - mountainOffset * 0.7, horizon + 60);
  ctx.lineTo(canvas.width + 100 - mountainOffset * 0.7, horizon + 60);
  ctx.lineTo(canvas.width + 100 - mountainOffset * 0.7, canvas.height);
  ctx.lineTo(50 - mountainOffset * 0.7, canvas.height);
  ctx.fill();

  // perspective floor plane to give a 3D feel
  const groundGrad = ctx.createLinearGradient(0, horizon, 0, canvas.height);
  groundGrad.addColorStop(0, "#2f4f4f");
  groundGrad.addColorStop(1, "#0f1f1f");
  ctx.fillStyle = groundGrad;
  ctx.beginPath();
  ctx.moveTo(0, horizon);
  ctx.lineTo(canvas.width, horizon);
  ctx.lineTo(canvas.width + 80, canvas.height);
  ctx.lineTo(-80, canvas.height);
  ctx.closePath();
  ctx.fill();

  // perspective grid lines
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  const vanishingX = canvas.width / 2;
  for (let i = -2; i <= 14; i++) {
    const t = i / 14;
    const startX = vanishingX + (t - 0.5) * canvas.width * 1.6;
    ctx.beginPath();
    ctx.moveTo(startX, horizon);
    ctx.lineTo(startX * 1.05, canvas.height);
    ctx.stroke();
  }
  for (let i = 0; i < 10; i++) {
    const lerp = i / 10;
    const y = horizon + (canvas.height - horizon) * Math.pow(lerp, 1.4);
    ctx.beginPath();
    ctx.moveTo(-80, y);
    ctx.lineTo(canvas.width + 80, y);
    ctx.stroke();
  }
}

function drawShadow(x, y, radius) {
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.scale(1, 0.35);
  ctx.beginPath();
  ctx.ellipse(x, (y + radius + 6) / 0.35, radius * 1.2, radius * 0.9, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawLevel() {
  const lvl = levels[currentLevel];
  const camX = Math.max(0, Math.min(player.x - 300, lvl.width - canvas.width));

  drawBackdrop(camX);

  // static platforms with faux depth
  for (let p of lvl.platforms) {
    const platX = p.x - camX;
    const grad = ctx.createLinearGradient(platX, p.y, platX, p.y + p.h);
    grad.addColorStop(0, "#2b9348");
    grad.addColorStop(1, "#15673f");
    ctx.fillStyle = grad;
    ctx.fillRect(platX, p.y, p.w, p.h);
    ctx.fillStyle = "#d0c9b5";
    ctx.fillRect(platX, p.y, p.w, 8);
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(platX, p.y + p.h - 6, p.w, 6);
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.beginPath();
    ctx.moveTo(platX + p.w, p.y + p.h);
    ctx.lineTo(platX + p.w + 16, p.y + p.h + 16);
    ctx.lineTo(platX + p.w + 16, p.y + 8);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath();
    ctx.moveTo(platX, p.y);
    ctx.lineTo(platX + p.w, p.y);
    ctx.lineTo(platX + p.w + 12, p.y + 12);
    ctx.lineTo(platX + 12, p.y + 12);
    ctx.closePath();
    ctx.fill();
  }

  // moving platforms
  for (let m of (lvl.movingPlatforms || [])) {
    const platX = m.x - camX;
    const grad = ctx.createLinearGradient(platX, m.y, platX, m.y + m.h);
    grad.addColorStop(0, "#4ea8de");
    grad.addColorStop(1, "#1d3557");
    ctx.fillStyle = grad;
    ctx.fillRect(platX, m.y, m.w, m.h);
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.fillRect(platX, m.y, m.w, 6);
  }

  // jump pads
  for (let pad of (lvl.jumpPads || [])) {
    const padX = pad.x - camX;
    const g = ctx.createLinearGradient(padX, pad.y, padX, pad.y + pad.h);
    g.addColorStop(0, "#ff9f1c");
    g.addColorStop(1, "#ff4040");
    ctx.fillStyle = g;
    ctx.fillRect(padX, pad.y, pad.w, pad.h);
    ctx.fillStyle = "rgba(255,255,255,0.45)";
    ctx.fillRect(padX, pad.y, pad.w, 4);
  }

  // hazards
  for (let hz of (lvl.hazards || [])) {
    const hx = hz.x - camX;
    ctx.fillStyle = "#b23a48";
    ctx.beginPath();
    for (let i = 0; i < hz.w; i += 20) {
      ctx.moveTo(hx + i, hz.y + hz.h);
      ctx.lineTo(hx + i + 10, hz.y + 12);
      ctx.lineTo(hx + i + 20, hz.y + hz.h);
    }
    ctx.fill();
    ctx.fillStyle = "#ffe066";
    ctx.fillRect(hx, hz.y + hz.h - 6, hz.w, 6);
  }

  // coins
  for (let c of lvl.coins) {
    drawShadow(c.x - camX, c.y + 10, 10);
    drawCoin({x: c.x - camX, y: c.y, taken: c.taken});
  }

  // enemies
  for (let e of lvl.enemies) {
    drawShadow(e.x - camX + e.w / 2, e.y + e.h, 18);
    drawEnemy({x: e.x - camX, y: e.y, w:e.w, h:e.h});
  }

  drawHelper(camX);

  // player shots
  ctx.fillStyle = "#ffd166";
  for (let s of player.shots) {
    ctx.beginPath();
    ctx.arc(s.x - camX, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#ff6b6b";
    ctx.stroke();
  }

  // finish
  const f = lvl.finish;
  if (f) {
    ctx.fillStyle = "purple";
    ctx.fillRect(f.x - camX, f.y, f.w, f.h);
  }

  // boss
  if ((currentLevel === 3 || currentLevel === 4) && boss && boss.active) {
    drawBoss(camX);
  }

  // player (with invincibility flicker)
  if (player.invincible === 0 || player.invincible % 10 < 5) {
    drawShadow(player.x - camX, player.y, player.r);
    drawCharacterBall(player.x - camX, player.y, player.r, characterChoice);
  }

  if (player.shieldTimer > 0 || player.helperBuff > 0) {
    const ring = ctx.createRadialGradient(player.x - camX, player.y, 10, player.x - camX, player.y, 40);
    ring.addColorStop(0, "rgba(255,255,255,0.4)");
    ring.addColorStop(1, "rgba(124,241,124,0.1)");
    ctx.fillStyle = ring;
    ctx.beginPath();
    ctx.arc(player.x - camX, player.y, 32, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* ======================================================================
   TITLE SCREEN
   ====================================================================== */

function drawTitleScreen() {
  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, "#1a1a2e");
  grad.addColorStop(1, "#16213e");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Title
  ctx.fillStyle = "#FFD700";
  ctx.strokeStyle = "#FF6B00";
  ctx.lineWidth = 4;
  ctx.font = "bold 72px sans-serif";
  ctx.strokeText("THE BOSSES", 200, 150);
  ctx.fillText("THE BOSSES", 200, 150);

  // Subtitle
  ctx.fillStyle = "white";
  ctx.font = "24px sans-serif";
  ctx.fillText("Created by Kai Nava", 310, 190);

  // Animated characters
  const bounce = Math.sin(Date.now() / 300) * 10;
  drawCharacterBall(300, 300 + bounce, 35, "bart");
  drawCharacterBall(450, 310 + bounce * 0.7, 35, "lisa");
  drawCharacterBall(600, 305 + bounce * 1.2, 35, "unicorn");

  // Instructions
  ctx.fillStyle = "#FFD700";
  ctx.font = "28px sans-serif";
  ctx.fillText("Click to Start!", 340, 420);

  // Controls
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.font = "18px sans-serif";
  ctx.fillText("Arrows/A-D to Move  •  Space to Jump/Glide  •  F to Fire  •  Q Special", 120, 460);
  ctx.fillText("Ride moving platforms, launch off orange pads, avoid spikes!", 170, 485);
}

/* ======================================================================
   CHARACTER SELECT SCREEN
   ====================================================================== */

const selectionCards = [
  { key: "bart", x: 70 },
  { key: "lisa", x: 330 },
  { key: "unicorn", x: 590 }
];

function drawCard(profile, type, x, y, width, height, isActive) {
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.shadowColor = "rgba(0,0,0,0.35)";
  ctx.shadowBlur = 14;
  ctx.shadowOffsetY = 6;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, 12);
  ctx.fill();
  ctx.restore();

  const accent = isActive ? "#ffd166" : "#fafafa";
  ctx.fillStyle = "rgba(255,255,255,0.08)";
  ctx.beginPath();
  ctx.roundRect(x + 4, y + 4, width - 8, height - 8, 10);
  ctx.fill();

  drawShadow(x + width / 2, y + 95, 24);
  drawCharacterBall(x + width / 2, y + 80, 32, type);

  ctx.fillStyle = accent;
  ctx.font = "18px sans-serif";
  ctx.fillText(profile.label, x + 12, y + 140);
  ctx.fillStyle = "#e0e0e0";
  ctx.font = "16px sans-serif";
  ctx.fillText(profile.specialName, x + 12, y + 166);

  ctx.fillStyle = "#cdd0d4";
  ctx.font = "14px sans-serif";
  const descWidth = width - 24;
  const words = profile.description.split(" ");
  let line = "";
  let lineY = y + 194;
  for (let word of words) {
    const testLine = line + word + " ";
    if (ctx.measureText(testLine).width > descWidth) {
      ctx.fillText(line, x + 12, lineY);
      line = word + " ";
      lineY += 18;
    } else {
      line = testLine;
    }
  }
  if (line) ctx.fillText(line, x + 12, lineY);
}

function drawCharacterSelect() {
  ctx.fillStyle = "#1b263b";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#ffd166";
  ctx.font = "32px sans-serif";
  ctx.fillText("Choose Your Character!", 250, 70);

  ctx.fillStyle = "#f1faee";
  ctx.font = "18px sans-serif";
  ctx.fillText("Click a card to lock in your hero", 310, 100);

  const cardY = 120;
  const cardW = 220;
  const cardH = 240;

  for (let card of selectionCards) {
    const profile = characterProfiles[card.key];
    const active = characterChoice === card.key;
    drawCard(profile, card.key, card.x, cardY, cardW, cardH, active);

    ctx.strokeStyle = active ? "#ffd166" : "rgba(255,255,255,0.3)";
    ctx.lineWidth = active ? 4 : 2;
    ctx.strokeRect(card.x + 2, cardY + 2, cardW - 4, cardH - 4);
  }

  ctx.fillStyle = "#e0e0e0";
  ctx.font = "16px sans-serif";
  ctx.fillText("Press space to jump • F to fire • Q to use your special", 220, 400);
  ctx.fillText("Click your pick to start the adventure!", 300, 430);

  canvas.onclick = function(ev) {
    const { offsetX: x, offsetY: y } = ev;
    for (let card of selectionCards) {
      if (x >= card.x && x <= card.x + cardW && y >= cardY && y <= cardY + cardH) {
        characterChoice = card.key;
        gameState = "play";
        startMusic();
        canvas.onclick = null;
        return;
      }
    }
  };
}

/* ======================================================================
   MAIN LOOP
   ====================================================================== */

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === "title") {
    drawTitleScreen();
  }
  else if (gameState === "characterSelect") {
    drawCharacterSelect();
  }
  else if (gameState === "play") {
    applyPhysics();
    drawLevel();
    drawHUD();
  }
  else if (gameState === "dead") {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = "red";
    ctx.font = "40px sans-serif";
    ctx.fillText("Game Over!", 330, 220);
    
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.fillText("You made it to Level " + currentLevel, 320, 260);
    ctx.fillText("Coins collected: " + player.coins, 340, 290);
    if (retriesLeft > 0) {
      ctx.fillText("Press R or click to retry level (" + retriesLeft + " left)", 260, 340);
    } else {
      ctx.fillText("Click to restart from the beginning", 290, 340);
    }
  }
  else if (gameState === "win") {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Victory text with glow
    ctx.shadowColor = "lime";
    ctx.shadowBlur = 20;
    ctx.fillStyle = "lime";
    ctx.font = "bold 48px sans-serif";
    ctx.fillText("YOU DEFEATED THE BOSS!", 160, 220);
    ctx.shadowBlur = 0;
    
    ctx.fillStyle = "#FFD700";
    ctx.font = "28px sans-serif";
    ctx.fillText("Total Coins: " + player.coins, 340, 280);
    
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.fillText("Click to play again", 350, 340);
  }

  requestAnimationFrame(loop);
}

resetGame();
loop();

</script>
</body>
</html>
